
## Loading and preparing the data

The first step is to load and prepare the trade data. This data set was extracted from the Convention on International Trade in Endangered Species of Wild Fauna and Flora (CITES), an international treaty organization tasked with monitoring, reporting, and providing recommendations on the international species trade. 

This data set contains records on every international import or export conducted with species from the CITES lists in 2016. It contains columns identifying the species, the import and export countries, and the amount and characteristics of the goods being traded (which range from live animals to skins and cadavers).

```{r   }
library(data.table)     # Run once per session
library(ggplot2)        # Run once per session
library(dplyr)          # Run once per session
library(igraph)         # Run once per session
library(DT)             # Run once per session
library(shiny)          # Run once per session
library(ggmap)
library(leaflet)
library(bslib)
library(sf)
library(geosphere)
library(RColorBrewer)
library(sp)





# Load data from file comptab_2018-01-29 16_00_comma_separated.csv 
dt.trade <- fread("../../data/cleaned_trade_data.csv") 


# Save dt.movie.actor. Next time you can simply call the load function (below)
save(dt.trade, file="trade.RData") 


# Load previously saved dt.trade You can start in this line if you have previously saved these data.
load("trade.RData") 

```

Exploratory Data Analaysis and Data Cleaning 

```{r}
#how many rows does our data set contain 
nrow(dt.trade)

#what are the different columns in our data set
colnames(dt.trade)

#countrylist
l.countries <- as.list(unique(dt.trade$reporter_name))


dt.trade <- dt.trade[complete.cases(dt.trade), ]


dt.country.coordinates <- dt.trade %>% distinct(partner_name, .keep_all = TRUE)
dt.country.coordinates <- dt.country.coordinates[, c("partner_name", "partner_lat", "partner_long")]
meta <- dt.country.coordinates %>% rename("name" = "partner_name", "lat" = "partner_lat", "lon" = "partner_long")
```



```{r}

#WEIGHTED MAP NOT ON SHINY APP

library(sp)
library(igraph)
library(leaflet)


# Subset the data to the country and year of interest
dt.trade.country <- dt.trade[reporter_name == "Germany"]
dt.trade.country.year <- dt.trade.country[year == 2018]
dt.trade.country.year <- dt.trade.country[trade_value_usd > 10000000000]

df <- data.frame("from" = dt.trade.country.year$reporter_name, 
               "to"= dt.trade.country.year$partner_name)

g <- graph.data.frame(df, directed = TRUE, vertices = meta)
g <- set_edge_attr(g, "weight", value= dt.trade.country.year$trade_value_usd)


gg <- get.data.frame(g, "both")
vert <- gg$vertices
coordinates(vert) <- ~lon + lat

edges <- gg$edges
weights <- E(g)$weight

edges <- lapply(1:nrow(edges), function(i) {
  as(rbind(vert[vert$name == edges[i, "from"], ], 
           vert[vert$name == edges[i, "to"], ]), 
     "SpatialLines")
})

for (i in seq_along(edges)) {
  edges[[i]] <- spChFIDs(edges[[i]], as.character(i))
}

edges <- do.call(rbind, edges)
edges_df <- data.frame(id = seq_along(edges), weight = weights)
edges <- SpatialLinesDataFrame(edges, data = edges_df)


pal <- colorNumeric(palette = "YlOrRd", domain = c(min(edges_df$weight), max(edges_df$weight)))

leaflet(vert) %>% 
  addTiles() %>% 
  addCircleMarkers(data = vert, radius = 2, 
                   color = "red", 
                   fillColor = "red", 
                   fillOpacity = 0.8,
                   stroke = FALSE) %>% 
  addPolylines(data = edges, weight = 2, color = ~pal(weight)) %>% 
  addLegend(position = "bottomright", pal = pal, values = edges_df$weight, 
            title = "Trade Value (USD)", labFormat = labelFormat(suffix = " USD", digits = 0))


```



````{r}

#SHINY APP WITH MAP


# Define UI --------------------------------------------------------------------

ui <- fluidPage(
  
      # App title ----
  titlePanel("Shiny App for International Trade"),
  
  navbarPage(title = "Network Analytics",
           tabPanel(title = "Rankings"),
           tabPanel(title = "Descriptive"),
           tabPanel(title = "Interactive Map"),
           theme = bs_theme(bg = "white",
                            fg = "black",
                            primary = "maroon",
                            base_font = font_google("Montserrat")
                            )
          ),
  
  
  sidebarLayout(
    
    # Inputs: Select variables to plot
    sidebarPanel(
      
      img(src = "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/World_Trade_Organization_%28logo_and_wordmark%29.svg/2560px-World_Trade_Organization_%28logo_and_wordmark%29.svg.png",width="100%"),
      
      # Select Trade
      selectInput(inputId = "trader", 
                  label = "Select Imports or Exports:",
                  choices = c("Exports"="reporter_name","Imports"="partner_name"), 
                  selected = "reporter_name"),
      
      # Select country
      selectInput(inputId = "country", 
                  label = "Select Country:",
                  choices = l.countries, 
                  selected = "Hungary"),
      
      # Select minimum weight
      sliderInput(inputId = "MinWeight",
                label = "Minimum Trade Value (USD):",
                min = 0,
                max = 20000000000,
                value = 0),
      
      
      # Set year range
      sliderInput(inputId = "year_range",
                  label = "Select Year Range:",
                  min = 1995,
                  max = 2022,
                  value = c(2018, 2022),
                  step = 1)
    ),
    
    
    # Output: Show network
    mainPanel(

      leafletOutput("map")
    )
  )
)


# Define server ----------------------------------------------------------------

server <- function(input, output, session) {

  output$map <- renderLeaflet({

    # Set the parameters
    if(input$trader=="reporter_name"){
      dt.trade.country <- dt.trade[ dt.trade$reporter_name == input$country, ]
      dt.trade.country.year <- dt.trade.country[dt.trade.country$year >= input$year_range[1] &
                                            dt.trade.country$year <= input$year_range[2], ]
      dt.trade.country.year <- dt.trade.country.year[dt.trade.country.year$trade_value_usd >                                                      input$MinWeight, ]

    } else {
      dt.trade.country <- dt.trade[ dt.trade$partner_name == input$country, ]
      dt.trade.country.year <- dt.trade.country[dt.trade.country$year >= input$year_range[1] &
                                            dt.trade.country$year <= input$year_range[2], ]
      dt.trade.country.year <- dt.trade.country.year[dt.trade.country.year$trade_value_usd >                                                      input$MinWeight, ]

    }

    df <- data.frame("from" = dt.trade.country.year$reporter_name,
                     "to"= dt.trade.country.year$partner_name)

    #checking if there is data from the inputs demanded my the user, if not, map shows a message saying         that no data is available

    if (nrow(df) == 0) {
      popup <- paste0("No data available for selected country")
      return(leaflet() %>% addTiles() %>% setView(lng = 0, lat = 0, zoom = 2) %>%
             addPopups(lng = 0, lat = 0, popup = popup))
    }

    g <- graph_from_data_frame(df, directed = TRUE, vertices = meta)
    g <- set_edge_attr(g, "weight", value = dt.trade.country.year$trade_value_usd)

    # Remove vertices with degree 0
    g <- delete.vertices(g, which(degree(g) == 0))

    gg <- get.data.frame(g, "both")
    vert <- gg$vertices
    coordinates(vert) <- ~lon + lat

    edges <- gg$edges
    weights <- E(g)$weight

    edges <- lapply(1:nrow(edges), function(i) {
      as(rbind(vert[vert$name == edges[i, "from"], ],
               vert[vert$name == edges[i, "to"], ]),
         "SpatialLines")
    })

    for (i in seq_along(edges)) {
      edges[[i]] <- spChFIDs(edges[[i]], as.character(i))
    }

    edges <- do.call(rbind, edges)
    edges_df <- data.frame(id = seq_along(edges), weight = weights)
    edges <- SpatialLinesDataFrame(edges, data = edges_df)


    pal <- colorNumeric(palette = "YlOrRd", domain = c(min(edges_df$weight), max(edges_df$weight)))
    
    
    leaflet(vert) %>%
      addProviderTiles("Stamen.Toner", options = providerTileOptions(noWrap = TRUE, zoomSnap = 0, 
                                                                     attributionControl = FALSE, 
                                                                     backgroundColor = "#f2f2f2",opacity = 
                                                                       0.4)) %>%
      addCircleMarkers(data = vert, radius = 2,
                   color = "red",
                   fillColor = "red",
                   fillOpacity = 0.8,
                   stroke = FALSE) %>%
      addPolylines(data = edges, weight = 2, color = ~pal(weight))



          })
}



# Create a Shiny app object ----------------------------------------------------

shinyApp(ui = ui, server = server)

```

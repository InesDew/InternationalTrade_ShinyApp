---
title: "R Notebook"
output: html_notebook
---



```{r}
library(data.table)     # Run once per session
library(ggplot2)        # Run once per session
library(igraph)         # Run once per session

dt.trade <- fread("../../data/cleaned_trade_data.csv")
dt.trade
```


```{r}
# Set the parameters
dt.trade.country <- dt.trade[reporter_name == "Afghanistan"]
dt.trade.country.year <- dt.trade.country[year == 2017]

# Set the vertices
dt.all.reporters <- dt.trade.country.year[, list(name=unique(reporter_name), type=FALSE)]
dt.all.partners <- dt.trade.country.year[, list(name=unique(partner_name), type=TRUE)]

dt.all.vertices <- rbind(dt.all.reporters, dt.all.partners)

# Create & plot the graph
g <- graph.data.frame(dt.trade.country.year[, list(reporter_name, partner_name)], directed=TRUE, vertices=dt.all.vertices)

plot(g, vertex.size = 5, vertex.label.cex = 0.6)

# Add weights to the graph & plot
g <- set_edge_attr(g, "weight", value= dt.trade.country.year$trade_value_usd)

plot(g, vertex.size = 5, vertex.label.cex = 0.6)
```


```{r}
# 1. Make edge list
dt.trade.year <- dt.trade[year == 2021]
dt.trade.year
dt.trade.edgelist <- dt.trade.year[ , c('reporter_name', 'partner_name')]
dt.trade.edgelist


# 2. Convert edge list to an igraph network
# igraph wants our data in matrix format
m.trade <- as.matrix(dt.trade.edgelist) 
g.trade <- graph_from_edgelist(m.trade, directed=TRUE)


# 3. Set the weight of the edges (trade_value_usd) & add the year as an attribute
E(g.trade)$weight <- dt.trade.year$trade_value_usd
  # Sum the weights for duplicate edges (we would need this if we select multiple years)
  g.trade <- simplify(g.trade, remove.multiple = TRUE, edge.attr.comb=list(weight="sum", year="concat"))

# 4. Add attributes to the vertices (continent)
library(rjson)
json_data <- fromJSON(file='../../data/sample.json')
V(g.trade)$continent <-  unlist(json_data[V(g.trade)$name])

# 5. Plot igraph
plot(g.trade, vertex.size = 5, vertex.label.cex = 0.3, edge.arrow.size=0.4)
```
```{r}
# 6. Run community detection algorithms
# Run Walktrap algorithm
walktrap_communities <- walktrap.community(g.trade, weights = E(g.trade)$weight)
# Print the number of communities detected
cat("Number of communities detected by Walktrap algorithm: ", length(unique(walktrap_communities$membership)), "\n")
# Plot the resulting clusters
plot(g.trade, vertex.size = 5, vertex.label.cex = 0.3, edge.arrow.size=0.4, vertex.color = walktrap_communities$membership)

#Modularity score: One way to evaluate the quality of the clustering is to calculate the modularity score, which measures the extent to which the nodes within a community are more densely connected to each other than to nodes outside the community. 
modularity(walktrap_communities, g)

# get the size of each community
sizes(walktrap_communities)

# Create a new graph object with community memberships as vertex attributes
g_comm <- set_vertex_attr(g.trade, "community", value = walktrap_communities$membership)
# Convert to igraph object
g_comm <- graph_from_data_frame(get.edgelist(g_comm), directed = TRUE)
# Compute edge betweenness for the entire graph
eb <- igraph::edge.betweenness(g)
# Find the top 10 edges with the highest edge betweenness
top10_eb <- order(eb, decreasing = TRUE)[1:10]
# Generate a vector of colors using the rainbow() function
color_eb <- rainbow(length(E(g)))
# Set the color of the top 10 edges with highest edge betweenness to red
color_eb[top10_eb] <- "red"
# Set the color of the remaining edges to transparent
color_eb[-top10_eb] <- "transparent"

plot(g.trade, vertex.size = 5, vertex.label.cex = 0.3, edge.arrow.size=0.4, vertex.color = walktrap_communities$membership, edge.color = color_eb)

# get the average path length for each community
apl_comm <- lapply(unique(walktrap_communities$membership), function(m) average.path.length(induced_subgraph(g.trade, V(g.trade)[walktrap_communities$membership == m])))
apl_all <- average.path.length(g.trade)
print(apl_all)
print(apl_comm)

```



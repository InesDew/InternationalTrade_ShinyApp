# In this file we preprocess the edges spatial object we use in the Communities
# analysis part of our app. This is done because the loading of the map 
# visualization was taking up to 2 minutes.

library(rgdal)
library(sf)
library(data.table)
library(igraph)
library(dplyr)  

data_file_path <- "app/src/cleaned_trade_data.csv"
dt.trade <- fread(data_file_path)

#dt.trade <- fread("app/src/cleaned_trade_data.csv")

for (year in seq(2000, 2021)) {
  # 1. Make edge list
  dt.trade.year <- dt.trade[dt.trade$year == 2021, ]
  dt.trade.edgelist <- dt.trade.year[ , c('reporter_name', 'partner_name')]
  
  # 2. Convert edge list to an igraph network
  # igraph wants our data in matrix format
  m.trade <- as.matrix(dt.trade.edgelist) 
  g.trade <- graph_from_edgelist(m.trade, directed=TRUE)
  
  # 3. Set vertex attributes using set_vertex_attr()
  l.reporters <- as.list(unique(dt.trade.year$reporter_name))
  l.partners <- as.list(unique(dt.trade.year$partner_name))
  l.countries <- as.list(unique(append(l.reporters, l.partners)))
  dt.country.coordinates <- dt.trade.year %>% distinct(partner_name, .keep_all = TRUE)
  dt.country.coordinates <- dt.country.coordinates[, c("partner_name", "partner_lat", "partner_long")]
  meta <- dt.country.coordinates %>% rename("name" = "partner_name", "lat" = "partner_lat", "lon" = "partner_long")
  
  meta <- meta[match(V(g.trade)$name, meta$name), ]
  V(g.trade)$lat <- meta$lat
  V(g.trade)$lon <- meta$lon
  
  # 4. Set the weight of the edges (trade_value_usd) & add the year as an attribute
  E(g.trade)$weight <- dt.trade.year$trade_value_usd
  # Remove vertices with degree 0
  g.trade <- delete.vertices(g.trade, which(degree(g.trade) == 0))
  
  # 5. Community detection: Walktrap algorithm
  walktrap_communities <- walktrap.community(g.trade, weights = E(g.trade)$weight)
  # Get the community membership vector
  membership_vec <- membership(walktrap_communities)
  # Add the community as an attribute to the vectors
  V(g.trade)$community <- membership_vec[V(g.trade)$name]
  
  # Compute edge betweenness for the entire graph
  eb <- igraph::edge.betweenness(g.trade)
  # Find the top 10 edges with the highest edge betweenness
  top10_eb <- order(eb, decreasing = TRUE)[1:10]
  # Generate a vector of colors using the rainbow() function
  color_eb <- rainbow(length(E(g.trade)))
  # Set the color of the top 10 edges with highest edge betweenness to red
  color_eb[top10_eb] <- "#000000"
    # Set the color of the remaining edges to transparent
  color_eb[-top10_eb] <- "transparent"
  
  # extract the vertices and edges from the g graph object and store them as a data frame
  gg <- get.data.frame(g.trade, "both")
  # assign vert variable with dataframe info on the vertices + add the spatial coordinates of the points to vert
  vert <- gg$vertices
  coordinates(vert) <- ~lon + lat
  
  # assign edges and weights variable
  edges <- gg$edges
  weights <- E(g.trade)$weight
  
  # Create a list of spatial objects
  edges <- lapply(1:nrow(edges), function(i) 
  {as(rbind(vert[vert$name == edges[i, "from"], ], 
            vert[vert$name == edges[i, "to"], ]), 
      "SpatialLines")
  })
  
  # assign unique IDs to each of the SpatialLines objects
  for (i in seq_along(edges)) {
    edges[[i]] <- spChFIDs(edges[[i]], as.character(i))
  }
  
  # combine all of the SpatialLines objects + new SpatialLinesDataFrame object 
  # using the combined SpatialLines object and the edges_df data frame.
  edges <- do.call(rbind, edges)
  edges_df <- data.frame(id = seq_along(edges), weight = weights)
  edges <- SpatialLinesDataFrame(edges, data = edges_df)
  
  name_file = paste0("edges_", year)
  
  # We save the SpatialPointsDataFrame edges
  writeOGR(edges, dsn = "app/src", layer = name_file, driver = "ESRI Shapefile")
}
